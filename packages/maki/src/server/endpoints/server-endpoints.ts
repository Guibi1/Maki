import { join } from "node:path";
import { ArkErrors, type Type } from "arktype";
import type { MatchingRoute, RouteFragment, ServerOptions } from "../server";
import type {
    OutputTypeOfExistingKeys,
    ServerEndpoint,
    ServerEndpointHandlerProps,
    ServerEndpointValidators,
} from "./types";

/**
 * Writes the global `MakiServerEndpoints` type into `api.d.ts` with the appropriate routes path.
 * @param router The app router
 * @param options The maki server options
 */
export async function writeGlobalApiEndpointsTypes(router: RouteFragment, { cwd }: ServerOptions) {
    const writer = Bun.file(join(cwd, "./src/api.d.ts")).writer();

    writer.write(
        "/**\n * Type definition generated by {@link https://github.com/Guibi1/Maki Maki}.\n */\ndeclare type MakiServerEndpoints = {\n",
    );

    function writeRouteTypes(route: RouteFragment) {
        if (route.endpoints?.size) {
            writer.write(
                `    "${route.path}": import("maki/server").MakiServerEndpoint<typeof import("./routes${route.path}/server")>;\n`,
            );
        }

        if (!route.routes) return;
        for (const subroute of Object.values(route.routes)) {
            writeRouteTypes(subroute);
        }
    }
    writeRouteTypes(router);

    writer.write("};\n");
    await writer.end();
}

/**
 * Calls a server endpoint with the validated body and route params.
 * @param endpoint The endpoint to call
 * @param route The route matched from the url
 * @param request The received request
 * @returns A response to send to the client
 */
export async function handleServerEndpoint(
    endpoint: ServerEndpoint,
    route: MatchingRoute,
    request: Request,
): Promise<Response> {
    if (typeof endpoint === "function") {
        return await endpoint({
            request,
            route: route.pathname,
            params: route.props.params,
        });
    }

    const body = endpoint.validators.body?.(await getBody(request));
    if (body instanceof ArkErrors) {
        return new Response(JSON.stringify({ success: false, message: body.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
        });
    }

    const searchParams = endpoint.validators.searchParams?.(route.props.searchParams);
    if (searchParams instanceof ArkErrors) {
        return new Response(JSON.stringify({ success: false, message: searchParams.message }), {
            status: 400,
            headers: { "Content-Type": "application/json" },
        });
    }

    const props: ServerEndpointHandlerProps & OutputTypeOfExistingKeys<Required<ServerEndpointValidators<Type, Type>>> =
        {
            request,
            route: route.pathname,
            params: route.props.params,
            body,
            searchParams,
        };

    const res = await endpoint.handler(props);
    return new Response(JSON.stringify(res), { headers: { "Content-Type": "application/json" } });
}

/**
 * Returns the json body of a request, or an empty object if the request doens't have a body.
 * @param request The request
 * @returns The body of the request
 */
async function getBody(request: Request): Promise<unknown> {
    if (request.method === "GET") {
        return {};
    }
    try {
        return await request.json();
    } catch (e) {
        console.error(e);
        return {};
    }
}
